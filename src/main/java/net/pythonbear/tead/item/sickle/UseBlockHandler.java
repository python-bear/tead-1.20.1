package net.pythonbear.tead.item.sickle;

import net.minecraft.block.Block;
import net.minecraft.block.BlockState;
import net.minecraft.block.Blocks;
import net.minecraft.entity.ExperienceOrbEntity;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.registry.Registries;
import net.minecraft.registry.RegistryKey;
import net.minecraft.registry.tag.BlockTags;
import net.minecraft.server.network.ServerPlayerEntity;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.sound.BlockSoundGroup;
import net.minecraft.sound.SoundCategory;
import net.minecraft.state.property.IntProperty;
import net.minecraft.util.ActionResult;
import net.minecraft.util.Hand;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.math.BlockBox;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Direction;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.shape.VoxelShapes;
import net.minecraft.world.GameRules;
import net.minecraft.world.World;
import net.pythonbear.tead.Tead;
import net.pythonbear.tead.item.SickleItem;
import net.pythonbear.tead.item.sickle.SickleHarvestEvents;
import net.pythonbear.tead.item.sickle.SickleHarvesting;

import java.util.NoSuchElementException;
import java.util.Optional;
import java.util.Random;

public final class UseBlockHandler {
    /**
     * Handles the event {@link UseBlockCallback}.
     * Will cancel further event processing only if the {@link PlayerEntity player}
     * is not in spectator mode,
     * is not crouching,
     * is holding the correct item (depends on {@link ModConfig#getRequireHoe() requireHoe})
     * and the interaction involves a fully grown {@link #isCrop crop}.
     *
     * @param player - {@link PlayerEntity player} executing the action.
     * @param world - {@link World world} where the event is happening.
     * @param hand - {@link Hand hand} player's hand.
     * @param result - {@link BlockHitResult} result of hitting the block.
     * @return - {@link ActionResult} result of the action.
     */
    public static ActionResult handle(PlayerEntity player, World world, Hand hand, BlockHitResult result) {
        ActionResult actionResult = ActionResult.PASS;

        assert player != null;
        if (!player.isSpectator()) {
            BlockPos blockPos = result.getBlockPos();
            BlockState blockState = world.getBlockState(blockPos);

            if (hand == Hand.MAIN_HAND && canHarvest(world, blockState, blockPos, player, hand, true)) {
                try {
                    IntProperty cropAge = SickleHarvesting.getAge(blockState);
                    if (SickleHarvesting.isMature(blockState, cropAge)) {
                        actionResult = ActionResult.SUCCESS;
                        if (!world.isClient()) {
                            harvest((ServerWorld) world, cropAge, blockState, blockPos, result.getSide(), result,
                                    (ServerPlayerEntity) player, hand);

                            if (player.getStackInHand(hand).getItem() instanceof SickleItem) {
                                BlockState state = world.getBlockState(blockPos);
                                if (canHarvest(world, state, blockPos, player, hand, false)) {
                                    IntProperty age = SickleHarvesting.getAge(state);
                                    if (SickleHarvesting.isMature(state, age)) {
                                        harvest((ServerWorld) world, age, state, result.getBlockPos(), result.getSide(),
                                                null, (ServerPlayerEntity) player, hand);
                                    }
                                }
                            }
                        }
                    }
                } catch (NullPointerException | NoSuchElementException | ClassCastException e) {
                    Tead.LOGGER.debug("Exception generated by block at [" + blockPos.toShortString() + "]");
                    Tead.LOGGER.debug("This is a non blocking error, but can result in incorrect behavior for mod "
                            + Tead.MOD_ID);
                    Tead.LOGGER.debug("Most probably the cause of this issue was that a non-crop ID was added in " +
                            "the configuration and its age property could not be retrieved, see stack trace for " +
                            "more details", e);
                }
            }
        }
        return actionResult;
    }

    /**
     * Checks whether the given {@link PlayerEntity} can right-click harvest the crop.
     * Dispatches the {@link SickleHarvesting#HARVEST_CHECK} event if the right-clicked block is indeed a crop.
     *
     * @param world - {@link World} of the interaction.
     * @param blockState - {@link BlockState} of the crop to harvest.
     * @param blockPos - {@link BlockPos} of the crop.
     * @param player - {@link PlayerEntity} trying to harvest.
     * @param hand - {@link Hand} being used to harvest the crop.
     * @param first - whether the current crop is the actual right-clicked crop.
     * @return whether the player can right-click harvest the crop.
     */
    private static boolean canHarvest(World world, BlockState blockState, BlockPos blockPos, PlayerEntity player,
                                      Hand hand, boolean first) {
        return SickleHarvesting.isCrop(blockState.getBlock()) && player.canHarvest(blockState) &&
                SickleHarvestEvents.HARVEST_CHECK.invoker().check(world, blockState, blockPos, player, hand, first,
                        new SickleHarvestEvents.HarvestCheckEvent());
    }
    /**
     * Harvests the crop, handles all related actions (exp granting, sickle damaging, dropping resources, etc.) and dispatches all related events.
     *
     * @param world - {@link ServerWorld world}.
     * @param age - {@link IntProperty age} of the crop.
     * @param blockState - {@link BlockState} of the crop.
     * @param blockPos - {@link BlockPos} of the crop.
     * @param face - clicked {@link Direction face} of the crop block.
     * @param hitResult - {@link BlockHitResult} of the {@link RightClickBlock} event.
     * @param player - {@link ServerPlayerEntity player} harvesting the crop.
     * @param hand - {@link InteractionHand hand} used to harvest.
     */
    private static void harvest(ServerWorld world, IntProperty age, BlockState blockState, BlockPos blockPos,
                                Direction face, BlockHitResult hitResult, ServerPlayerEntity player, Hand hand) {
        SickleHarvestEvents.BEFORE_HARVEST.invoker().beforeHarvest(world, blockState, blockPos, face, hitResult, player,
                hand, hitResult != null);
        BlockPos basePos = getBasePos(world, blockState.getBlock(), blockPos);
        grantExp(world, basePos);
        damageSickle(player, hand);
        updateCrop(world, age, blockState.getBlock(), basePos, player, dropResources(world,
                world.getBlockState(basePos), basePos, face, hitResult, player, hand));
        playSound(world, blockState, blockPos);
        SickleHarvestEvents.AFTER_HARVEST.invoker().afterHarvest(world, blockState, blockPos, face, hitResult, player,
                hand, hitResult != null);
    }
    /**
     * Plays the block breaking sound.
     *
     * @param world - {@link ServerWorld} to play the sound.
     * @param blockState - {@link BlockState state} of the block emitting the sound.
     * @param blockPos - {@link BlockPos position} of the block emitting the sound.
     */
    private static void playSound(ServerWorld world, BlockState blockState, BlockPos blockPos) {
        BlockSoundGroup soundGroup = blockState.getBlock().getSoundGroup(blockState);
        world.playSound(null, blockPos, soundGroup.getBreakSound(), SoundCategory.BLOCKS, soundGroup.getVolume(),
                soundGroup.getPitch());
    }
    /**
     * Updates the crop in the world, reverting it to age 0 (simulate replanting) and, if it's a multi-block crop, breaks the crop blocks above.
     *
     * @param world - {@link ServerWorld world}.
     * @param age - {@link IntProperty age} of the crop.
     * @param block - {@link Block} of the clicked crop.
     * @param basePos - {@link BlockPos} of the clicked crop base.
     * @param player - {@link ServerPlayerEntity player} harvesting the crop.
     * @param customDrops - whether {@link HarvestDrops} listeners have changed the drops to drop.
     */
    private static void updateCrop(ServerWorld world, IntProperty age, Block block, BlockPos basePos,
                                   ServerPlayerEntity player, boolean customDrops) {
        world.setBlockState(basePos, block == Blocks.PITCHER_CROP ? Blocks.AIR.getDefaultState() :
                world.getBlockState(basePos).with(age, 0));
        if (world.getBlockState(basePos).isIn(BlockTags.CROPS) && world.getBlockState(basePos.up()).isOf(block) &&
                !isTallButSeparate(block)) {
            world.breakBlock(basePos.up(), !customDrops, player);
        }
    }
    /**
     * Returns the base pos of the clicked crop.
     *
     * @param world - {@link ServerWorld world}.
     * @param block - {@link Block} of the clicked crop.
     * @param blockPos - {@link BlockPos} of the crop block clicked.
     * @return the base pos of the clicked crop.
     */
    private static BlockPos getBasePos(ServerWorld world, Block block, BlockPos blockPos) {
        BlockPos basePos;
        for (basePos = blockPos; world.getBlockState(blockPos).isIn(BlockTags.CROPS) && !isTallButSeparate(block) &&
                world.getBlockState(basePos.down()).isOf(block); basePos = basePos.down());
        return basePos;
    }
    /**
     * Grants the given player the configured amount of experience, if any.
     *
     * @param world
     * @param pos
     */
    private static void grantExp(ServerWorld world, BlockPos pos) {
        if (world.getGameRules().getBoolean(GameRules.DO_TILE_DROPS)) {
            Random random = new Random();
            int experienceAmount = random.nextInt(2) + 1;

            ExperienceOrbEntity.spawn(world, Vec3d.ofCenter(pos), experienceAmount);
        }
    }
    /**
     * Does one damage to the sickle.
     *
     * @param player - {@link ServerPlayerEntity player} holding the sickle.
     * @param hand - {@link Hand hand} holding the sickle.
     */
    private static void damageSickle(ServerPlayerEntity player, Hand hand) {
        if (!player.isCreative()) {
            Random random = new Random();
            int randomNumber = random.nextInt(2) + 1;

            player.getStackInHand(hand).damage(randomNumber, player,
                    playerEntity -> playerEntity.sendToolBreakStatus(hand));
        }
    }
    /**
     * Drop the resources resulting from harvesting a crop in the given {@link ServerWorld world} and {@link BlockState blockState}, making them pop from the given face and using the item held in the given player hand.
     * Takes care of dispatching the {@link SickleHarvestEvents#HARVEST_DROPS} to retrieve the drops resulting from the harvest.
     *
     * @param world - {@link ServerWorld server world} the drops should come from.
     * @param blockState - {@link BlockState state} of the crop being harvested.
     * @param blockPos - crop {@link BlockPos position}.
     * @param face - {@link Direction face} clicked of the crop.
     * @param hitResult - {@link BlockHitResult} of the {@link RightClickBlock} event.
     * @param player - {@link ServerPlayer player} harvesting the crop.
     * @param hand - {@link InteractionHand hand} used to harvest the crop.
     * @return whether {@link HarvestDrops} listeners have changed the drops to drop.
     */
    private static boolean dropResources(ServerWorld world, BlockState blockState, BlockPos blockPos, Direction face,
                                         BlockHitResult hitResult, ServerPlayerEntity player, Hand hand) {
        SickleHarvestEvents.HarvestDropsEvent event = new SickleHarvestEvents.HarvestDropsEvent(world, blockState,
                blockPos, player, hand);
        for (ItemStack stack : SickleHarvestEvents.HARVEST_DROPS.invoker().getDrops(world, blockState, blockPos, face,
                hitResult, player, hand, hitResult != null, event)) {
            if (blockState.getCollisionShape(world, blockPos) != VoxelShapes.empty()) {
                Block.dropStack(world, blockPos, face, stack);
            } else {
                Block.dropStack(world, blockPos, stack);
            }
        }
        return event.haveDropsChanged();
    }
    /**
     * Checks whether the given block is something that might be considered a tall crop, but should actually be treated as a normal crop.
     * <p>
     * Currently the only known crop with this behavior is Farmer's Delight tomatoes.
     *
     * @param block
     * @return whether to treat a tall crop as a normal crop.
     */
    private static boolean isTallButSeparate(Block block) {
        Optional<RegistryKey<Block>> key = Registries.BLOCK.getKey(block);
        if (key.isPresent()) {
            return key.get().getValue().toString().equals("farmersdelight:tomatoes");
        }
        return false;
    }
    /**
     * Expand a {@link BlockBox} horizontally.
     *
     * @param box
     * @param distance
     * @return the expanded {@link BlockBox}.
     */
    private static BlockBox expandHorizontally(BlockBox box, int distance) {
        return new BlockBox(box.getMinX() - distance, box.getMinY(), box.getMinZ() - distance,
                box.getMaxX() + distance, box.getMaxY(), box.getMaxZ() + distance);
    }
}